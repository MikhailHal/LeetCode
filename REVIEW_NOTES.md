# 復習必須問題リスト

## 🔄 Two Pointers & Sliding Window

### 560. Subarray Sum Equals K
**本質理解の判断基準:**
- なぜ最初に考えたSliding Windowアプローチが使えなかったか
- Prefix Sum + ハッシュマップの組み合わせが必要な理由
- 実装時のチェック→記録の順番が重要な理由
- 初期値の設定理由

### 567. Permutation in String  
**本質理解の判断基準:**
- アナグラム問題を効率的に解くアプローチ
- 固定サイズウィンドウでの差分更新手法
- 辞書比較のタイミング

### 283. Move Zeroes
**本質理解の判断基準:**
- Write Pointerパターンとは何か
- 最初に試したアプローチの計算量問題
- in-place操作での正しい実装方法
9/15 X

## 🔗 Linked List

### 19. Remove Nth Node From End of List  
**本質理解の判断基準:**
- Fast/Slowポインタの位置関係理論
- dummy nodeが必要になるケース
- while条件で境界を正しく処理する方法

### 234. Palindrome Linked List
**本質理解の判断基準:**
- Fast/Slowで中央を検出する仕組み
- 奇数長リストでの中央ノードの扱い
- なぜ後半を反転するのか
- 奇偶判定の効率的な方法

## 🎯 Dynamic Programming

### 322. Coin Change
**本質理解の判断基準:**
- 部分問題の定義：「dp[i] = i円を作る最小枚数」
- 最適化パターン：minを使った最小値選択
- 「最後の操作」で場合分けする思考法（最後に使うコイン）
- float('inf')の使用理由（作れない状態の表現）
- なぜGreedyでは解けないか（反例を説明できる）
- dp初期化の重要性（0円=0枚、他は∞）

## 🚨 特に注意すべき思考パターン

### 問題1: 解法選択の判断基準
- どんな時にどのアプローチを選ぶか
- 制約条件から適切な手法を選ぶ思考過程

### 問題2: 実装の簡潔性
- 最小限で動くコードを書く意識
- 不要な複雑化を避ける判断力

### 問題3: 境界条件の処理
- エッジケースでの正しい動作保証
- インデックス計算での off-by-one エラー回避

---

## 復習時のチェックポイント

1. **5分以内に基本実装**ができるか
2. **なぜその解法を選んだか**を説明できるか  
3. **他の解法との比較**ができるか
4. **計算量**を正しく分析できるか
5. **類似問題への応用**ができるか

---

*Generated: 2025-01-XX*