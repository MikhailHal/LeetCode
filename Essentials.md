# Essentials

## 遅延評価的な保存パターン

### 気づき（Two Sum）
- 同じ数字でも時点によって役割が変わる
  - `num=2`の時点: ただの数値
  - `num=7`の時点: 2は「7の補数」として参照される
- 保存時点で「これは補数だ」とラベル付けする必要がない
- `{数値: index}`で保存 → 後から補数として使われるかは未来が決める

### 抽象
**「保存 → 後から来たデータが意味を与える」**

- 保存すべきもの vs 計算できるものを区別する
- 計算できるもの（例: 補数）は保存しない
- 状態として持つものを最小化する

### 使えると気づくトリガー
- **「2つの要素間の関係」を探している**（ペア、差分、大小関係など）
- **今の要素だけでは答えが決まらない**（相方が必要）
- 愚直に書くとO(n²)の全探索になりそう

### 目的・メリット
- **O(n²) → O(n)** に計算量を落とせる
- 「探す」のではなく「後から見つけてもらう」発想で、ロジックがシンプルになる
- 辞書1つで済む（状態管理が最小化される）

### 別具体
| パターン | 保存するもの | 後から決まること |
|---------|-------------|----------------|
| Monotonic Stack | 要素 | 「次に大きい要素」が誰か |
| Prefix Sum | 累積和 | どの区間の和として使われるか |
| Merge Intervals | 区間 | マージされるかどうか |

## DFS/BFSの使い分け

### 気づき（Number of Islands）
- グリッド = グラフ（各マスがノード、4方向がエッジ）
- 「島の数」= 連結成分の数 = DFSで塊ごと訪問済みにしてカウント
- 「最短」を求めるならBFS、それ以外はDFSで十分

### 抽象
**「最短 → BFS、それ以外 → DFS」**

- BFSは「近い順」に探索 → 最初に見つけた答えが最短
- DFSは「奥まで行って戻る」 → 全探索・連結判定に向く
- どちらも「全部見る」が、見る順序が違う

### 使えると気づくトリガー
- **「最短」「最小ステップ」「最小回数」** → BFS必須
- **「連結成分の数」「到達できるか」「全パターン列挙」** → DFS（BFSでも可）
- グリッド問題で「塊」を扱う → DFSが書きやすい

### 目的・メリット
- BFS: 最短が保証される（重みなしグラフ）
- DFS: 再帰で書けてシンプル、スタック管理が楽

### 別具体
| 問題 | 使うべき | 理由 |
|------|----------|------|
| 200. Number of Islands | DFS | 連結成分を数えるだけ |
| 111. Minimum Depth of Binary Tree | BFS | 「最小」深さ |
| 994. Rotting Oranges | BFS | 「最短」時間 |
| 695. Max Area of Island | DFS | 面積を数えるだけ |
